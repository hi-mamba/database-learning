 
<https://segmentfault.com/a/1190000040206818>

<https://www.modb.pro/db/71948>

[图解redis五种数据结构底层实现(动图哦)](https://i6448038.github.io/2019/12/01/redis-data-struct/)

<https://juejin.cn/post/7064359936842530830>

# 简单动态字符串（SDS）

Redis `自己构建`了一种名为简单动态字符串（`simple dynamic string`，SDS）的抽象类型， 
并将 SDS 用作 Redis 的默认字符串表示。
>  set msg "hello world"  

key 和 value 底层都是用 SDS 来实现的。

## SDS 的结构

```go
struct sdshdr {

    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];

};
```
- free 还剩多少空间
- len 字符串长度
- buf 存放的字符数组
  > 数组的最后一个字节保存了空字符 '\0'

## 数据结构优化
在 `Redis3.x 版`本中不同长度的字符串占用的`头部是相同`的，
如果某一字符串很短但是头部却占用了更多的空间，这未免太浪费了。
所以我们将 SDS 分为三种级别的字符串

- 短字符串(长度小于32)，len和free的长度用1字节即可；
- 长字符串，用2字节或者4字节；
- 超长字符串，用8字节。

## 频繁内存分配问题处理
> 每次增长或者缩短一个字符，程序都需要对保存这个字符串的数组进行一次内存重新分配操作。
因为内存重分配涉及复杂的算法，并且可能需要`执行系统调用`，所以它通常是一个比较耗时的操作

为了避免C字符串的这种缺陷，SDS通过未使用空间`解除了字符串长度`和`底层数组长度`之间的关联。
通过未使用空间，SDS实现了`空间预分配`和`惰性空间释放`两种优化策略。

## 空间预分配
为减少修改字符串带来的内存重分配次数，sds采用了“一次管够”的策略：

- 若修改之后`sds长度小于1MB`,则多分配现有len长度的空间
- 若修改之后`sds长度大于等于1MB`，则扩充除了满足修改之后的长度外，额外`多1MB`空间

## 惰性空间释放

为避免缩短字符串时候的`内存重分配`操作，sds在数据减少时，
SDS `字符串缩短`时并不`立即使用内存重分配`来回收缩短后多出来的空间,
而仅仅更新 SDS 的`len属性`，多出来的空间供将来使用。

<img width="1207" alt="image" src="https://user-images.githubusercontent.com/7867225/157360574-83cf12cd-de4c-4dcf-9d6c-4f033b842645.png">

sdstrim(s, "XY"); // 移除 SDS 字符串中的所有 'X' 和 'Y' 

<img width="1196" alt="image" src="https://user-images.githubusercontent.com/7867225/157360550-c2bd0a07-b5b8-470f-9a7f-d8b0ab83f1cd.png">



### 这没真正释放空间，是否会导致内存泄漏呢?
SDS为我们提供了真正释放SDS未使用空间的方法`sdsRemoveFreeSpace`


## SDS 与C 语音字符串比较

1. SDS 获取字符串长度`时间复杂度O(1)`：因为 SDS 通过 len 字段来存储长度，
   使用时直接读取就可以；C 语言要想获取字符串长度需要遍历整个字符串，时间复杂度O(N)。
   
2. SDS 能杜绝缓冲区的溢出：因为当 SDS API 要对 SDS 进行修改时，
   会先检查 SDS 的空间是否足够，如果不够的话 `SDS 会自动扩容`，
   不会造成缓冲区溢出。而 C 语言则不具有这个功能。
   
3. SDS 能减少修改字符串时带来的`内存重分配`次数：
    - `空间预分配`：当SDS 扩容时不只是会增加需要的空间大小，还会`额外的分配`一些`未使用的空间`。
      分配的规则是：如果分配后SDS的`长度小于 1MB`，那么会分配`等于`分配后SDS 的大小的未使用空间，
      简单说就是，SDS 动态分配后是 16KB，那么就会多分配 16KB 的未使用空间；
      如果 `小于 1MB`，那么分配 1MB 的未使用空间。
      
    - `惰性空间释放`： 惰性空间释放用于优化 SDS 的字符串缩短操作：
      当 SDS 的 API 需要`缩短 SDS` 保存的字符串时，并不会立即内存重分配来回收多出来的字节，
      而是用 `free` 来记录`未使用空间`。

## SDS 会自动扩容

SDS 的自动扩容机制完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，
API会`先检查 SDS 的空间`是否满足修改所需的要求，如果不满足，
API会自动将SDS的空间`扩展`至执行修改所需的大小，然后才执行实际的修改操作，
所以使用 SDS 既不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。

SDS 的`sds sdscat(sds s, const char *t)方法`在字符串`拼接`时会进行扩容相关操作

### 自动扩容机制——sdsMakeRoomFor方法

`strcatlen`中调用`sdsMakeRoomFor`完成字符串的容量检查及扩容操作

### 扩容阶段：

- 若 SDS 中`剩余空闲空间 avail` 大于`新增内容的长度 addlen`，则无需扩容；
- 若 SDS 中剩余空闲空间 avail 小于或等于新增内容的长度 addlen：
    - 若新增后总长度 len+addlen < 1MB，则按新长度的两倍扩容；
    -  若新增后总长度 len+addlen > 1MB，则按新长度加上 1MB 扩容

### 内存分配阶段：

- 根据扩容后的长度选择对应的 SDS 类型：
    - 若类型不变，则只需通过 s_realloc_usable扩大 buf 数组即可；
    - 若类型变化，则需要为整个 SDS 重新分配内存，并将原来的 SDS 内容拷贝至新位置

## 二进制安全

什么是二进制安全？
通俗地讲，C语言中，用`'0'`表示`字符串的结束`，如果字符串`本身就有'0'字符`，字符串就会`被截断`，
即非二进制安全；若`通过某种机制`，保证读写字符串时`不损害其内容`，则是二进制安全。

SDS使用`len属性`的`值判断字符串是否结束`，所以不会受`'\0'`的影响。


## SDS 最长多少？

[Redis 官方给出了最大的字符串容量为 512MB。](https://redis.io/topics/data-types)
> A String value can be at max 512 Megabytes in length.

在 `Reids3.x` 版本中len是使用`int`修饰的，这就会导致 buf 最长就是`2147483647`，
`无形中限制`了字符串的最大长度。

`_sdsnewlen`方法创建 SDS 中都会调用`sdsTypeMaxSize`方法获取每种类型所能创建的最大buf长度
不难发现此方法最大的返回值为2147483647，即512MB。

## 创建SDS
Redis 通过`sdsnewlen方法`创建 SDS。在方法中会根据`字符串初始化长度`选择`合适的类型`。

## 释放SDS
为了优化性能，SDS 提供了不直接释放内存，
而是通过重置len达到清空 SDS 目的的方法——sdsclear。
改方法仅仅将 SDS 的`len归零`，而buf的空间并为真正被清空，
新的数据可以复写，而不用重新申请内存。

```go
void sdsclear(sds s) {
    sdssetlen(s, 0);// 设置len为0
    s[0] = '\0';//“清空”buf
}
```

若真正想清空 SDS 则可以调用sdsfree方法，底层通过调用s_free释放内存。

```go
void sdsfree(sds s) {
    if (s == NULL) return;
    s_free((char*)s-sdsHdrSize(s[-1]));
}

```
