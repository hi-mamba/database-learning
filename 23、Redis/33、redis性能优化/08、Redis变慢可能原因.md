
原文：<https://mp.weixin.qq.com/s/Qc4t_-_pL4w8VlSoJhRDcg>

# Redis变慢可能原因

CPU 相关：使用复杂度过高命令、数据的持久化，都与耗费过多的 CPU 资源有关

内存相关：bigkey 内存的申请和释放、数据过期、数据淘汰、碎片整理、内存大页、内存写时复制都与内存息息相关

磁盘相关：数据持久化、AOF 刷盘策略，也会受到磁盘的影响

网络相关：短连接、实例流量过载、网络流量过载，也会降低 Redis 性能

计算机系统：CPU 结构、内存分配，都属于最基础的计算机系统知识

操作系统：写时复制、内存大页、Swap、CPU 绑定，都属于操作系统层面的知识

## 业务服务器到 Redis 服务器之间的`网络存在问题`
> 例如网络线路质量不佳，网络数据包在传输时存在延迟、丢包等情况

## `Redis 本身存在问题`，需要进一步排查是什么原因导致 Redis 变慢


### 使用复杂度过高的命令

> 你需要去查看一下 Redis 的慢日志（slowlog）

### 1. 经常使用 O(N) 以上复杂度的命令，例如 SORT、SUNION、ZUNIONSTORE `聚合类命令`
> Redis 在操作内存数据时，时间复杂度过高，要花费更多的 CPU 资源

### 2. 使用 O(N) 复杂度的命令，但 N 的值非常大
> Redis一次需要返回给客户端的数据过多，更多时间花费在数据协议的组装和网络传输过程中。

如果你的应用程序操作 Redis 的 OPS 不是很大，
但 Redis 实例的 `CPU 使用率却很高`，那么很有可能是使用了`复杂度过高的命令`导致的。

Redis 是`单线程处理客户端请求`的，如果你经常使用以上命令，
那么当 Redis 处理客户端请求时，一旦`前面某个命令发生耗时`，
就会`导致后面的请求发生排队`，对于客户端来说，响应延迟也会变长。
> 比如：可能复杂的 lua 脚本

### 3. bigkey的写入和释放

### 4. 实例内存达到上限
> 原因在于，当 Redis 内存达到 maxmemory 后，
每次写入新的数据之前，Redis 必须先从实例中踢出一部分数据，
让整个实例的内存维持在 maxmemory 之下，然后才能把新数据写进来

### 5. fork 耗时严重
当 Redis 开启了后台 RDB 和 AOF rewrite 后，在执行时，
它们都需要主进程创建出一个子进程进行数据的持久化。

fork 在执行过程中，主进程需要拷贝自己的`内存页表`给子进程，
如果这个实例很大，那么这个拷贝的过程也会比较耗时。

### 6. 开启内存大页
应用程序向操作系统申请内存时，是按内存`页`进行申请的，而常规的内存页大小是 `4KB`

### 7. 使用 Swap

### 8. 碎片整理
> 开启内存碎片整理，它也有可能会导致 Redis 性能下降

### 网络带宽过载


### 频繁短连接
> 频繁的短连接会导致 Redis 大量时间耗费在连接的建立和释放上，
TCP 的三次握手和四次挥手同样也会增加访问延迟

### 运维监控
因为配置和使用问题，导致监控程序频繁地与 Redis 建立和断开连接，导致 Redis 响应变慢

### 其它程序争抢资源
你的 Redis 机器最好专项专用，只用来部署 Redis 实例，不要部署其他应用程序

## 解决方案


尽量`不使用 O(N) `以上复杂度过高的命令，对于数据的聚合操作，放在客户端做。

执行 O(N) 命令，保证 N 尽量的小（推荐 N <= 300），
每次`获取尽量少的数据`，让 Redis 可以及时处理返回。


如果你查询慢日志发现，并不是复杂度过高的命令导致的，
而都是 SET / DEL 这种简单命令出现在慢日志中，
那么你就要怀疑你的实例`否写入了 bigkey`。
