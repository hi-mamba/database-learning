
<https://mp.weixin.qq.com/s/Qc4t_-_pL4w8VlSoJhRDcg>

<https://blog.csdn.net/wangwei222/article/details/80927255>

# 复制父进程的空间内存页表可能出现问题

fork 在执行过程中，主进程需要`拷贝`自己的`内存页表`给子进程，如果这个实例很大，
那么这个拷贝的过程也会比较耗时。

如果子进程存在期间，发生了`大量的写操作`，那可能就会出现很多的分页错误(页异常中断page-fault)，
这样就得耗费不少性能在复制上。

## fork()系统调用

fork()系统调用用来生成子进程，而现有Linux系统运行在写时拷贝的机制下，
于是fork()函数在为子进程建立内核中各种管理结构的时候，
并没有将`真实的物理资源`分配给子进程，而只是将`父进程`的物理资源`共享`给子进程。

fork()函数会将父进程的`物理内存`共享给子进程,
即将`父进程多级页表`的内容`复制`到子进程新建立的`多级页表`中。
然而在这种机制下，
对于父进程中那些原本可读可写的页，一旦`被共享给子进程`之后，两个进程中`任何一个`对该物理页内容进行了`修改`，
将会`影响另外一个进程`的正常使用

## 内核解决此问题的方法：
在将父进程的多级页表`复制`到子进程的多级页表中时，会将之前对于父进程来说`可写`的物理页对应的页表项，
在父子进程的多级页表中都`设置为只读`，
因此，一旦两个进程中的任何一个对某个`写保护（只读）的物理页`发生了`写操作`，
就会导致`pagefault（分页错误）`，相应的内核函数会处理并识别出这种`写时拷贝机制`导致的错误，
并`复制`该物理页的内容到一个`新的物理页`，并将新的物理页`链接`到发生写操作的进程的`多级页表`中，
最后恢复该物理页对应表项的写权限，恢复进程对该物理页的写操作，做到进程无感知的处理。








版权声明：本文为CSDN博主「北方南方」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wangwei222/article/details/80927255
