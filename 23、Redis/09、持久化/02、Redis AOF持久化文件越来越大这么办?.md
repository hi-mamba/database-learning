
[原文](https://cloud.tencent.com/developer/article/1081994)

# Redis AOF持久化文件越来越大这么办?

> AOF文件重写（rewrite）,创建一个新的AOF文件代替旧的AOF文件,直接从数据库中读取所有的键值。

AOF持久化是通过`保存写命令`来记录数据库状态的，所以AOF文件中的内容会越来越多，
文件的体积也会越来越大，如果不加以控制的话，体积过大的 AOF文件很可能对Redis服务器、
甚至整个宿主计算机造成影响，并且AOF文件的体积越大，
使用AOF文件来进行数据还原所需的时间就越多

## 示例：

> redis> RPUSH list "A" "B"

结果：["A", "B"]

> redis> RPUSH list "C"

结果：["A", "B", "C"]

> redis> RPUSH list "D" "E"

结果：["A", "B", "C", "D", "E"]

> redis> LPOP list

结果：["B", "C", "D", "E"]

> redis> LPOP list

结果：["C", "D", "E"]

AOF文件需要保存每条命令，从最后结果来看，很明显，`其中有的命令是无意义的`，
因为它们不影响数据库状态

为了解决AOF文件体积膨胀的问题，Redis提供了`AOF文件重写（rewrite）`功能，
`创建一个新的AOF文件`来`替代`现有的AOF文件，新旧文件所保存的数据库状态相同，
但新AOF文件不会包含任何冗余命令，所以体积会比旧的小得多

## AOF重写的实现原理

例如上面的例子，如果想要用尽量少的命令来记录list键的状态，
那么最简单高效的办法`不是`去读取和分析现有AOF文件的内容，
而是`直接从数据库中读取键list的值`，然后执行

> RPUSH list "C" "D" "E"

这一条命令就可以代替之前的5条命令，就可以将保存list键所需的命令从5条减少为一条了

实现原理：首先从数据库中读取键现在的值，然后用一条命令去记录键值对，
代替之前记录这个键值对的多条命令

## AOF后台重写

重写会进行大量的写入操作，会阻塞服务器线程，无法处理新的命令请求

为解决这个问题，Redis将AOF重写程序放到`子进程`里执行，这样，父进程就可以继续处理命令请求

但同时也会产生一个新的问题，子进程在进行AOF重写期间，
服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而产生数据库状态不一致

为了解决数据不一致问题，Redis服务器设置了一个`AOF重写缓冲区`，
这个缓冲区在服务器`创建子进程`之后开始使用，当服务器执行完一个写命令之后，
它会将这个写命令发送给`AOF重写缓冲区`

当子进程完成AOF重写工作之后，它会`向父进程发送一个信号`，父进程在接到该信号之后，会调用信号处理函数，执行以下工作：

1）将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件与当前的数据库状态一致

2）对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换

在整个`AOF后台重写`过程中，只有`信号处理函数`执行时会对服务器造成阻塞

![](/images/redis/redis_aof_rewrite.jpeg)

## [AOF重写的具体实现](https://www.cnblogs.com/chichung/p/12687101.html)

![image](https://user-images.githubusercontent.com/7867225/157565316-7f87807b-b205-40b0-8fa2-dda216c0ce82.png)

> AOF重写缓冲区：aof_rewrite_buf

（1）开始`bgrewriteaof`，判断当前有没有bgsave命令(RDB持久化)/bgrewriteaof在执行，倘若有，则这些命令执行完成以后在执行。

（2）主进程fork出子进程，在这一个短暂的时间内，`redis是阻塞的`。

（3）主进程fork完子进程继续接受客户端请求。此时，客户端的写请求不仅仅写入`aof_buf缓冲区`，
还`写入aof_rewrite_buf重写缓冲区`。一方面是写入aof_buf缓冲区并根据appendfsync策略同步到磁盘，
保证原有AOF文件完整和正确。另一方面写入aof_rewrite_buf重写缓冲区，
保存fork之后的客户端的写请求，防止新AOF文件生成期间丢失这部分数据。

（4.1）子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。

（4.2）主进程把aof_rewrite_buf中的数据写入到新的AOF文件。

（5.）使用新的AOF文件覆盖旧的AOF文件，标志AOF重写完成。


