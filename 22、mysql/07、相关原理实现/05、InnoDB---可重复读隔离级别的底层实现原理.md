
<https://zhuanlan.zhihu.com/p/166152616>

##### [原文](https://blog.csdn.net/chuixue24/article/details/86536372)

##### [Innodb的快照读实现](https://htchz.cc/3647734067.html)

# InnoDB---可重复读隔离级别的底层实现原理

## 可重复读的实现

在InnoDB中，会在每行数据后添加`两个额外`的`隐藏的值`来实现MVCC，
这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 
在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 

### 在可重读Repeatable reads事务隔离级别下：
```
SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或 > 当前事务版本号。
INSERT时，保存当前事务版本号为行的创建版本号
DELETE时，保存当前事务版本号为行的删除版本号
UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行
```
通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，
但可以减少锁的使用，大多数读操作都不用加锁，
读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行



### RR隔离级别是怎么保证`不能看到其他事务对已有记录的更新`这一点的呢？

使用MVCC（多版本并发控制）,InnoDB为`每行记录添加了一个版本号`（系统版本号），`每当修改数据时，版本号加一`。
 
在读取事务开始时，系统会给`事务一个当前版本号`，事务会`读取`版本号<=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，
新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。

 如果数据库并发控制引擎是单纯的封锁协议机制，则应该在读取数据的时候，判断数据项是不是其他事务更新过的。
 可是InnoDB没有这么做，而是通过如下方式，在RR隔离级别下为事务设置了一个“`一致性读视图`（即快照）”，之后读取数据，
 就是`根据这个快照来获取`，这样，就不能看到他晚于本事务的事务对已有记录的更新（更新生成新版本，必然不在旧的快照所限定的范围内）
    
## 可重复读实现原理

Innodb的已提交读和可重复读隔离级别下，读有`快照读`（snapshot read）和`当前读`（current read）之分,
当前读就是`SELECT ... LOCK IN SHARE MODE`和`SELECT ... FOR UPDATE`，快照读就是`普通的SELECT`操作。

快照读的实现，利用了`undo log`和`read view`。

快照读不是在`读的时候`生成快照，而是在`写的时候保留了旧版本数据`。

快照读实现了`Multi-Version Concurrent Control`（多版本并发控制），简称MVCC，
指对于`同一个记录`，`不同的事务`会有`不同的版本`，`不同版本互不影响`，
最后事务提交时`根据版本先后`确定能否提交。

但是，Innodb的读写事务会加`排他锁`，不同版本其实是串行的，所以首先要指出的是，
Innodb事务快照读不是严格的MVCC实现


## Innodb在RR级别如何避免幻读

[Next-Key Locking锁机制避免了幻读问题](../06、mysql锁/11、Next-Key Locking锁机制避免了幻读问题.md)
