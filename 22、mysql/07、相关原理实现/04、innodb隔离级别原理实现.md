
## [原文](https://ncs123.iteye.com/blog/2396186)

# innodb隔离级别原理实现

> `间隙锁`和`行锁合`称next-key lock，每个next-key lock是前开后闭区间

- 利用MVCC实现一致性非锁定读，这就有保证在同一个事务中多次读取相同的数据返回的结果是一样的，解决了`不可重复读`的问题
 
> 事务的隔离性是由锁来实现，而原子性、一致性、持久性通过redo和undo完成。

## 可重复读
在`可重复读`级别下，mvcc完全解决了`重复读`，但**并不能真正的完全`避免幻读`**，只是在部分场景下利用历史数据规避了幻读

对于快照读，mysql使用mvcc利用历史数据部分避免了幻读（在某些场景看上去规避了幻读）

要完全避免，需要手动加锁将`快照读`调整为`当前读`（mysql不会自动加锁），然后mysql使用next-key完全避免了幻读

### [可重复读隔离级别的底层实现原理](05、InnoDB---可重复读隔离级别的底层实现原理.md)
 

## 如何解决幻读？

1. 在快照读读情况下，mysql通过`mvcc来避免幻读`。

2. 在当前读读情况下，mysql通过`next-key来避免幻`。

使用 `Next-Key lock` 解决幻读

> next-key锁 = 行锁+间隙锁(GAP)

产生幻读的原因是，`行锁`只能`锁住行`，但是`新插入记录`这个动作，要更新的是记录之间的“`间隙`”。
因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是`间隙锁`(Gap Lock)。
 
顾名思义，间隙锁，锁的就是`两个值之间的空隙`。

利用`Next-Key lock`可以阻止其它事务在`锁定区间内插入数据`，因此解决了`幻读`问题