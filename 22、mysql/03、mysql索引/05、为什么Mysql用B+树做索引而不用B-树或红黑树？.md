## [参考](http://www.10tiao.com/html/667/201812/2652080677/1.html)

<https://zhuanlan.zhihu.com/p/348169887>

<https://blog.csdn.net/Fly_as_tadpole/article/details/88169841>


# 为什么MySQL数据库要用B+树存储索引？

数据库索引采用B+树而不是B树的主要原因：B+树只要`遍历叶子节点`就可以实现整棵树的遍历，
而且在数据库中`基于范围的查询`是非常频繁的，而B树只能`中序遍历`所有节点，效率太低


## 为什么索引结构默认使用B-Tree，而不是hash，二叉树，红黑树？

hash：虽然可以快速定位，但是`没有顺序`，IO复杂度高。

二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

红黑树：树的高度随着数据量增加而增加，IO代价高。


## 为什么官方建议使用自增长主键作为索引。

结合B+Tree的特点，自增主键是连续的，在插入过程中尽量`减少页分裂`，
即使要进行页分裂，也只会分裂很少一部分


## 为什么Mysql用B+树做索引而不用B-树或红黑树？

B树是`多路树`，红黑树是`二叉树`,红黑树`一个节点`只能存出`一个值`，
B树`一个节点`可以存储`多个值`，
红黑树的深度会更大,定位时 红黑树的查找次数会大一些。

AVL 数和红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，
`红黑树`往往出现由于`树的深度`过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。

### 为什么会出现这样的情况?
我们知道要获取`磁盘上数据`，必须先通过磁盘`移动臂`移动到数据所在的`柱面`，
然后找到指定`盘面`，接着旋转盘面找到数据所在的`磁道`，最后对数据进行读写。

磁盘IO代价主要花费在`查找所需的柱面`上，`树的深度`过大会造成磁盘IO频繁读写。
根据磁盘查找存取的次数往往由树的高度所决定，
所以，只要我们通过某种较好的`树结构`减少树的结构尽量`减少树的高度`，
B树可以有多个子女，从几十到上千，可以降低树的高度。

数据库系统的设计者巧妙利用了`磁盘预读原理`，将一个节点的大小设为等于一个页，
这样每个节点只需要一次I/O就可以完全载入。

为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接`申请一个页`的空间，
这样就保证一个节点物理上也存储在一个页里，
加之`计算机存储分配`都是`按页`对齐的，就实现了一个node只需一次I/O。


## [拓展：hashmap为什么用红黑二叉树而不用B+树？](https://www.jianshu.com/p/a7a2bddfa5ac)

B+树在数据库中被应用的原因就是B+树比B树更加“矮胖”，
B+树的非叶子结点不存储数据，所以每个结点能存储的关键字更多。所以`B+树更能应对大量数据`的情况。

jdk1.7中的HashMap本来是`数组+链表`的形式，链表由于其`查找慢`的特点，
所以需要被查找效率更高的树结构来替换(`红黑树`)。

如果用B+树的话，在`数据量`不是很多的情况下，数据都会`“挤在”一个结点`里面。
这个时候遍历效率就`退化成了链表`



