原文：

<https://www.guitu18.com/post/2019/11/24/61.html>

<https://xiaomi-info.github.io/2019/12/24/mysql-implicit-conversion/>

# MySQL中的隐式转换造成的索引失效


## 结论

### 查阅MySQL相关文档发现是隐式转换造成的，看一下官方的描述：

官方文档：[12.2 Type Conversion in Expression Evaluation](https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html?spm=5176.100239.blogcont47339.5.1FTben)

当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。
例如，MySQL会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：

1. 两个参数至少有一个是NULL时，比较的结果也是NULL，特殊的情况是使用<=>对两个NULL做比较时会返回1，这两种情况都不需要做类型转换
2. 两个参数都是字符串，会按照字符串来比较，不做类型转换
3. 两个参数都是整数，按照整数来比较，不做类型转换
4. 十六进制的值和非数字做比较时，会被当做二进制串
5. 有一个参数是TIMESTAMP或DATETIME，并且另外一个参数是常量，常量会被转换为timestamp
6. 有一个参数是decimal类型，如果另外一个参数是decimal或者整数，会将整数转换为decimal后进行比较，如果另外一个参数是浮点数，则会把decimal转换为浮点数进行比较
7. 所有其他情况下，两个参数都会被转换为`浮点数`再进行比较


### MySQL使用操作符的一些特性

- 当操作符`左右两边的数据类型`不一致时，会发生`隐式转换`。
- 当where查询操作符左边为`数值类型`时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。
- 当where查询操作符左边为`字符类型`时发生了隐式转换，那么会`导致索引失效`，造成全表扫描效率极低。
- 字符串转换为数值类型时，非数字开头的字符串会转化为0，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。


## 详情


### 转换浮点数例子

```mysql
CREATE TABLE `t1` (
  `c1` varchar(255) NOT NULL DEFAULT '',
  KEY `idx_c1` (`c1`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into t1 values('1234567890123456789');
insert into t1 values('123456789012345678');
insert into t1 values('123456789012345677');
insert into t1 values('12345678901234567');
insert into t1 values('12345678901234568');
insert into t1 values('123456789012345');
```

> select * from t1 where c1=123456789012345678;

查询出两条数据，并且 123456789012345677 不等于查询条件


```mysql
explain select * from t1 where c1=12345678901234567;

+----+-------------+-------+------------+-------+---------------+--------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key    | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+--------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t1    | NULL       | index | idx_c1        | idx_c1 | 767     | NULL |    6 |    16.67 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+--------+---------+------+------+----------+--------------------------+

```

rows 全表扫描

 
根据上面的规则()，分析开始的示例，c1 字段类型是 varchar，等号右边常量是数字，
MySQL 会把 `c1 字段的值和数字常量转换成浮点数`比较。
 
当字段是字符串跟数字比较时，MySQL 不能使用索引来加快查询

### 浮点数转换
MySQL 里使用了 dtoa 这个转换类库来实现字符跟浮点数的相互转换，一是提高了浮点数的精度（相比 c 标准库）, 二是保持平台一致性。

在 MySQL 里浮点数之间的比较是近似的。
因为 MySQL 里浮点数是不精确的，它的精度位只有 `53 比特`，大于 53 比特的位被“四舍五入”。这会导致一些违反直观的结果。

比如下面两个 SQL

```mysql
mysql> SELECT '1801537632024345812' = 1801537632024345812;
        -> 1
mysql> SELECT '1801537632024345812' = 1801537632024345813;
        -> 1
```

比较结果都是相等，这里就发生了浮点数转换。
我们来看下到底发生了什么。

浮点数

```mysql
SELECT '1801537632024345812'+0.0;
+---------------------------+
| '1801537632024345812'+0.0 |
+---------------------------+
|     1.8015376320243459e18 |
+---------------------------+
```
转换成浮点数后对应的整数

```mysql
SELECT cast('1801537632024345812' + 0.0 as unsigned);
+-----------------------------------------------+
| cast('1801537632024345812' + 0.0 as unsigned) |
+-----------------------------------------------+
|                           1801537632024345856 |
+-----------------------------------------------+

SELECT cast('1801537632024345813' + 0.0 as unsigned);
+-----------------------------------------------+
| cast('1801537632024345813' + 0.0 as unsigned) |
+-----------------------------------------------+
|                           1801537632024345856 |
+-----------------------------------------------+
```
转换成浮点数后在转换成整数，对应的都是

> 1801537632024345856

分别对应的二进制

```
1801537632024345812 -> 11001000000000101100011101110011011100100111100111100（53）11010100
1801537632024345856 -> 11001000000000101100011101110011011100100111100111101（53）00000000
```
对比可以看到 53 位后的数据被丢掉，因为第 54 位是 1，所以有一个进位。

再看下我们的示例数字转换成浮点数后分别对应的数字

```mysql
select c1, cast(c1 + 0.0 as unsigned) from t1;
+---------------------+----------------------------+
| c1                  | cast(c1 + 0.0 as unsigned) |
+---------------------+----------------------------+
| $                   |                          0 |
| 123456789012345     |            123456789012345 |
| 12345678901234567   |          12345678901234568 |
| 12345678901234568   |          12345678901234568 |
| 123456789012345677  |         123456789012345680 |
| 123456789012345678  |         123456789012345680 |
| 1234567890123456789 |        1234567890123456768 |
+---------------------+----------------------------+
```


### 字符串隐式转换的规则

>  SELECT 'a'+123, 's'+'234', 5+'ab', 66+'1.a.2kj', CONCAT(56, 'go');

- 不以数字开头的字符串都将转换为0。如'abc'、'a123bc'、'abc123'都会转化为0；

- 以数字开头的字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。
比如'123abc'会转换为123，'012abc'会转换为012也就是12，'5.3a66b78c'会转换为5.3，其他同理。


### 隐式查询
```mysql
CREATE TABLE `test1` (
    `id` int(11) NOT NULL,
    `num1` int(11) NOT NULL DEFAULT '0',
    `num2` varchar(11) NOT NULL DEFAULT '',
    `type1` int(4) NOT NULL DEFAULT '0',
    `type2` int(4) NOT NULL DEFAULT '0',
    `str1` varchar(100) NOT NULL DEFAULT '',
    `str2` varchar(100) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `num1` (`num1`),
    KEY `num2` (`num2`),
    KEY `type1` (`type1`),
    KEY `str1` (`str1`),
    KEY `str2` (`str2`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
```mysql
2: SELECT * FROM `test1` WHERE num1 = 10000;
3: SELECT * FROM `test1` WHERE num1 = '10000';
```


第23两条SQL都发生了隐式转换，第2条SQL的查询条件num1 = '10000'，左边是int类型右边是字符串，
第3条SQL相反，那么根据官方转换规则第7条，左右两边都会转换为浮点数再进行比较。

先看第2条SQL：SELECT * FROM `test1` WHERE num1 = '10000'; 
左边为int类型10000，转换为浮点数还是10000，右边字符串类型'10000'，转换为浮点数也是10000。
两边的转换结果都是唯一确定的，所以不影响使用索引。

第3条SQL：SELECT * FROM `test1` WHERE num2 = 10000; 左边是字符串类型'10000'，转浮点数为10000是唯一的，
右边int类型10000转换结果也是唯一的。但是，因为左边是检索条件，'10000'转到10000虽然是唯一，
但是其他字符串也可以转换为10000，比如'10000a'，'010000'，'10000'等等都能转为浮点数10000，这样的情况下，是不能用到索引的。


 
