
# 定期删除策略


在redis源码中，实现定期淘汰策略的是函数activeExpireCycle，每当周期性函数serverCron执行时，该函数会调用databasesCron函数;然后databasesCron会调用activeExpireCycle函数进行主动的过期键删除。具体方法是在规定的时间内，多次从expires中随机挑一个键，检查它是否过期，如果过期则删除。
首先这个函数有两种执行模式，一个是快速模式一个是慢速模式，体现在代码中就是timelimit这个变量中，这个变量是用来约束这个函数的运行时间的，我们可以考虑这样一个场景，就是数据库中有很多过期的键需要清理，那么这个函数就会一直运行很长时间，这样一直占用CPU显然是不合理的，所以需要这个变量来约束，当函数运行时间超过了这个阈值，就算还有很多过期键没有清理，函数也强制退出。
在快速模式下，timelimit的值是固定的，是一个预定义的常量ACTIVE_EXPIRE_CYCLE_FAST_DURATION，在慢速模式下，这个变量的值是通过下面的代码计算的。
timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;

他的计算依据是之前预定义好的每次迭代只能占用的CPU时间比例，以及这个函数被调用的频率。
Redis中也可能有多个数据库，所以这个函数会遍历多个数据库来清楚过期键 ，但是是根据下面代码的原则来确定要遍历的数据库的个数的。
 if (dbs_per_call > server.dbnum || timelimit_exit)
        dbs_per_call = server.dbnum;

dbs_per_call变量就是函数会遍历的数据库的个数，他有一个预定义的值REDIS_DBCRON_DBS_PER_CALL，但是如果这个值大于现在redis中本身的数据库的个数，我们就要将它的值变成当前的数据库的实际个数，或者上次的函数是因为超时强制退出了，说明可能有的数据库在上次函数调用时没有遍历到，里面的过期键没有清理掉，所以也要将这次遍历的数据库的个数改成实际数据库的个数。
for (j = 0; j < dbs_per_call; j++) {
    int expired;
    redisDb *db = server.db+(current_db % server.dbnum);
      current_db++;

上面代码可以看出：数据库的遍历是在这个大的for循环里，其中值得留意的是current_db这个变量是一个static变量，这么做的好处是，如果真的发生了我们上面说的情况，上一次函数调用因为超时而强制退出，这个变量就会记录下这一次函数应该从哪个数据库开始遍历，这样会使得函数用在每个数据库的时间尽量平均，就不会出现有的数据库里面的过期键一直没有清理的情况。
每个数据库的过期键清理的操作是在下面的这个do while 循环中（由于代码过长，所以中间有很多代码我把它隐藏了，现在看到的只是一个大框架，稍后我会对其中的部分详细讲解）
do {
    ... 
    /* If there is nothing to expire try next DB ASAP. */
    if ((num = dictSize(db->expires)) == 0) {
    ... 
    }
    slots = dictSlots(db->expires);
    now = mstime();

    if (num && slots > DICT_HT_INITIAL_SIZE &&
        (num*100/slots < 1)) break;
        ...
    if (num > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)
        num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;

    while (num--) {
     ... 
    }
    /* Update the average TTL stats for this database. */
    if (ttl_samples) {
    ...
    }
    iteration++;
    if ((iteration & 0xf) == 0) { /* check once every 16 iterations. */
    ...
    }
    if (timelimit_exit) return;

} while (expired > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);

注意while循环条件，ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP是我们每个循环希望查到的过期键的个数，如果我们每次循环过后，被清理的过期键的个数超过了我们期望的四分之一，我们就会继续这个循环，因为这说明当前数据库中过期键的个数比较多，需要继续清理，如果没有达到我们期望的四分之一，就跳出while循环，遍历下一个数据库。
这个函数最核心的功能就是清除过期键，这个功能的实现就是在while（num--）这个循环里面。
while (num--) {
    dictEntry *de;
    long long ttl;

    if ((de = dictGetRandomKey(db->expires)) == NULL) break;
    ttl = dictGetSignedIntegerVal(de)-now;
    if (activeExpireCycleTryExpire(db,de,now)) expired++;
    if (ttl < 0) ttl = 0;
    ttl_sum += ttl;
    ttl_samples++;
}

他先从数据库中设置了过期时间的键的集合中随机抽取一个键，然后调用activeExpireCycleTryExpire函数来判断这个键是否过期，如果过期就删除键，activeExpireCycleTryExpire函数的源码如下：
int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {
    long long t = dictGetSignedIntegerVal(de);
    if (now > t) {
        sds key = dictGetKey(de);
        robj *keyobj = createStringObject(key,sdslen(key));

        propagateExpire(db,keyobj);
        dbDelete(db,keyobj);
        notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,
            "expired",keyobj,db->id);
        decrRefCount(keyobj);
        server.stat_expiredkeys++;
        return 1;
    } else {
        return 0;
    }
}

这个函数的逻辑很简单，就是先获取键de的过期时间，和现在的时间比较，如果过期，就生成该键de的对象，然后传播该键de的过期信息，并且删除这个键，然后增加过期键总数。
最后就是控制函数运行时间的部分了，代码如下：
/* We can't block forever here even if there are many keys to
 * expire. So after a given amount of milliseconds return to the
 * caller waiting for the other active expire cycle. */
iteration++;
if ((iteration & 0xf) == 0) { /* check once every 16 iterations. */
    long long elapsed = ustime()-start;

    latencyAddSampleIfNeeded("expire-cycle",elapsed/1000);
    if (elapsed > timelimit) timelimit_exit = 1;
}
if (timelimit_exit) return;     

这里有一个迭代次数的变量iteration，每迭代16次就来计算函数已经运行的时间，如果这个时间超过了之前的限定时间timelimit，就将timelimit_exit这个标志置为1，说明程序超时，需要强制退出了。

作者：JackFrost_fuzhu
链接：https://www.jianshu.com/p/5b00456125da
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。