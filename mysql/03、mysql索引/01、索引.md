

# 索引

## 介绍

![](../../images/mysql/innodb_index-10.png)

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。

根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？

如果语句是select * from people where id=15，即主键查询方式，则只需要搜索ID这棵B+树；

如果语句是select * from people where age=34，即普通索引查询方式，则需要先搜索age索引树，得到 id 的值为 15，
再到ID索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。


## 主键索引和普通索引的区别：
主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)

## 索引类型：
主键索引、非主键索引

主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)


## 总结

1. 索引的作用：提高数据查询效率

2. 常见索引模型：哈希表、有序数组、搜索树

3. 哈希表：键 - 值(key - value)。

4. 哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置

5. 哈希冲突的处理办法：链表

6. 哈希表适用场景：只有等值查询的场景

7. 有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))

8. 有序数组查询效率高，更新效率低

9. 有序数组的适用场景：静态存储引擎。

10. 二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子

11. 二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))

12. 数据库存储大多不适用二叉树，因为树高过高，会适用N叉树

13. InnoDB中的索引模型：B+Tree

14. 索引类型：主键索引、非主键索引
主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)

15. 主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)

16. 一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。
空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。

17. 从性能和存储空间方面考量，自增主键往往是更合理的选择。



## 问题
如果你要重建索引 k，你的两个SQL语句可以这么写：
```MYSQL
alter table T drop index k;
alter table T add index(k);

```
如果你要重建主键索引，也可以这么写：

```mysql
alter table T drop primary key;
alter table T add primary key(id);

```
我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？