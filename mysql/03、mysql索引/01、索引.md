
## [原文](https://www.cnblogs.com/duanxz/p/3799045.html)

# 索引


## 索引的本质
> MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，
这些数据结构以某种方式引用（指向）数据，
这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引


## 没有索引时mysql是如何查询到数据的

索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。
考虑如下情况，假设数据库中一个表有10^6条记录，DBMS的页面大小为4K，
并存储100条记录。如果没有索引，查询将对整个表进行扫描，最坏的情况下，
如果所有数据页都不在内存，需要读取10^4个页面，
如果这10^4个页面在磁盘上随机分布，需要进行10^4次I/O，
假设磁盘每次I/O时间为10ms(忽略数据传输时间)，
则总共需要100s(但实际上要好很多很多)。
如果对之建立B-Tree索引，则只需要进行log100(10^6)=3次页面读取，
最坏情况下耗时30ms。这就是索引带来的效果，很多时候，
当你的应用程序进行SQL查询速度很慢时，应该想想是否可以建索引。

进入正题：

## 什么是索引？

索引（在MYSQL中也叫做键<key>），是存储引擎用于快速找到记录的一种数据结构。
索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。
如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。
表里面的记录数量越多，这个操作的代价就越高。
如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。
如果表有1000个记录，通过索引查找记录至少要比顺序扫描记录快100倍。 

　　索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。
考虑如下情况，假设数据库中一个表有10^6条记录，DBMS的页面大小为4K，并存储100条记录。
如果没有索引，查询将对整个表进行扫描，最坏的情况下，如果所有数据页都不在内存，需要读取10^4个页面，
如果这10^4个页面在磁盘上随机分布，需要进行10^4次I/O，假设磁盘每次I/O时间为10ms(忽略数据传输时间)，
则总共需要100s(但实际上要好很多很多)。如果对之建立B-Tree索引，则只需要进行log100(10^6)=3次页面读取，
最坏情况下耗时30ms。这就是索引带来的效果，很多时候，当你的应用程序进行SQL查询速度很慢时，
应该想想是否可以建索引。

索引优化应该是对查询性能优化最有效的手段了，索引能够轻易将查询性能提高几个数量级，
”最优“的索引有时比一个”好的“索引性能要好两个数量级。创建一个真正”最优“的索引经常要重写查询。


## [索引的类型](02、索引的类型.md)


##  [参考](https://github.com/MrLining/mysql/wiki/mysql%E7%B4%A2%E5%BC%95%E8%BF%9B%E9%98%B6)

## [参考](https://www.cnblogs.com/duanxz/tag/mysql/)


## 介绍

![](../../images/mysql/innodb_index-10.png)

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。

根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？

如果语句是select * from people where id=15，即主键查询方式，则只需要搜索ID这棵B+树；

如果语句是select * from people where age=34，即普通索引查询方式，则需要先搜索age索引树，得到 id 的值为 15，
再到ID索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。


## 主键索引和普通索引的区别：
主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)

## 索引类型：
主键索引、非主键索引

主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)


## 总结

1. 索引的作用：提高数据查询效率

2. 常见索引模型：哈希表、有序数组、搜索树

3. 哈希表：键 - 值(key - value)。

4. 哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置

5. 哈希冲突的处理办法：链表

6. 哈希表适用场景：只有等值查询的场景

7. 有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))

8. 有序数组查询效率高，更新效率低

9. 有序数组的适用场景：静态存储引擎。

10. 二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子

11. 二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))

12. 数据库存储大多不适用二叉树，因为树高过高，会适用N叉树

13. InnoDB中的索引模型：B+Tree

14. 索引类型：主键索引、非主键索引
主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)

15. 主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)

16. 一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。
空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。

17. 从性能和存储空间方面考量，自增主键往往是更合理的选择。

