

# 一条更新语句执行的顺序(日志两段提交)

你一定听过 MySQL 事务的两阶段提交，指的就是在事务提交的时候，分成` prepare `和 `commit` 两个阶段。

![](../../images/mysql/mysql_server_666666.png)
```mysql
update T set c=c+1 where ID=2;
```

![](../../images/mysql/log/update_log.png)

- `执行器`先找`存储引擎`取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，
就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

- `执行器`拿到`存储引擎`给的行数据，`把这个值加上 1`，比如原来是 N，现在就是 N+1，得到新的一行数据，再`调用存储引擎接口写入`这行新数据。

- `存储引擎`将这行新数据`更新到内存`中，同时将这个`更新操作记录到 redo log` 里面，此时 redo log 处于 `prepare` 状态。
然后`告知执行器`执行完成了，随时可以提交事务。

- `执行器`生成这个操作的 `binlog`，并把 `binlog 写入磁盘`。

- `执行器`调用`存储引擎`的提`交事务接口`，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。


## 问题

### 写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash）

由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个`事务会回滚`。这时候，binlog 还没写，所以也不会传到备库。

###  binlog 写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？

我们先来看一下崩溃恢复时的判断规则。
1. 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；
2. 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：
   - a. 如果是，则提交事务；
   - b. 否则，回滚事务。

### MySQL 怎么知道 binlog 是完整的?

一个事务的 binlog 是有完整格式的：

- statement 格式的 binlog，最后会有 `COMMIT`；
- row 格式的 binlog，最后会有一个 `XID event`。

另外，在 MySQL 5.6.2 版本以后，还引入了 `binlog-checksum `参数，用来验证 binlog 内容的正确性。
对于 binlog 日志由于磁盘原因，可能会在日志中间出错的情况，`MySQL 可以通过校验 checksum 的结果`来发现。
所以，MySQL 还是有办法验证`事务 binlog 的完整性`的。


### 处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?

其实，这个问题跟`数据与备份`的`一致性`有关。在时刻 B，也就是 binlog 写完以后 MySQL 发生崩溃，
这时候 binlog 已经写入了，之后就会`被从库（或者用这个 binlog 恢复出来的库）使用`。

所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了`一致性`。

### 如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？

其实，两阶段提交是经典的分布式系统问题，并不是 MySQL 独有的。

### 不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？

我把这个问题再翻译一下的话，是说只保留 binlog，然后可以把提交流程改成这样：… -> “数据更新到内存” -> “写 binlog” -> “提交事务”，
是不是也可以提供崩溃恢复的能力？

答案是不可以。

我说一个不支持的点吧：binlog 没有能力恢复“数据页”。
```
prepare-1
   | 
binlog-1
   |
commit-1
   | 
prepare-2
   |
binlog-2
   |     > 这里发生 crash
commit-2

```
如果在上面的标的位置，也就是 binlog2 写完了，但是整个事务还没有 commit 的时候，MySQL 发生了 crash。

重启后，引擎内部事务 2 会回滚，然后应用 binlog2 可以补回来；
但是对于事务 1 来说，系统已经认为提交完成了，不会再应用一次 binlog1。
> 事务 1 也是可能丢失了的，而且是数据页级的丢失。此时，binlog 里面并`没有记录数据页`的更新细节，是补不回来的。
>> 你如果要说，那我优化一下 binlog 的内容，让它来记录数据页的更改可以吗？可以，但这其实就是又做了一个 `redo log `出来。

> InnoDB 引擎使用的是 WAL 技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要`依赖于日志来恢复数据页`。

### 那能不能反过来，只用 redo log，不要 binlog？

如果只从崩溃恢复的角度来讲是可以的。你可以把 binlog 关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的。


但是 redo log 是循环写，写到末尾是要回到开头继续写的。这样`历史日志没法保留`，`redo log 也就起不到归档的作用`。
  
一个就是 MySQL `系统依赖于 binlog`。binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。
其中，MySQL 系统高可用的基础，就是 binlog 复制。
  
  还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL 的 binlog 来更新自己的数据。
关掉 binlog 的话，这些下游系统就没法输入了。
